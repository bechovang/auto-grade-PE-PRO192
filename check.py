import os
import subprocess
import re
from pathlib import Path

class JavaTestRunner:
    def __init__(self, java_dir, test_dir):
        self.java_dir = Path(java_dir)
        self.test_dir = Path(test_dir)
        self.src_dir = self.java_dir / "src"
        
    def compile_java(self):
        """Bi√™n d·ªãch c√°c file Java"""
        print("=== Bi√™n d·ªãch Java files ===")
        java_files = list(self.src_dir.glob("*.java"))
        
        if not java_files:
            print("Kh√¥ng t√¨m th·∫•y file .java n√†o!")
            return False
            
        # Compile t·∫•t c·∫£ java files v·ªõi UTF-8 encoding
        compile_cmd = ["javac", "-encoding", "UTF-8"] + [str(f) for f in java_files]
        
        try:
            result = subprocess.run(
                compile_cmd,
                capture_output=True,
                text=True,
                cwd=str(self.src_dir)
            )
            
            if result.returncode != 0:
                print(f"L·ªói bi√™n d·ªãch:\n{result.stderr}")
                return False
            else:
                print("‚úì Bi√™n d·ªãch th√†nh c√¥ng!")
                return True
        except Exception as e:
            print(f"L·ªói khi bi√™n d·ªãch: {e}")
            return False
    
    def find_main_class(self):
        """T√¨m class c√≥ ph∆∞∆°ng th·ª©c main() - th·ª≠ main, Main, v√† t√¨m t·ª± ƒë·ªông"""
        # Th·ª≠ c√°c t√™n ph·ªï bi·∫øn tr∆∞·ªõc
        common_names = ["main", "Main"]
        for name in common_names:
            class_file = self.src_dir / f"{name}.class"
            if class_file.exists():
                print(f"‚úì T√¨m th·∫•y class: {name}")
                return name
        
        # N·∫øu kh√¥ng c√≥, t√¨m trong c√°c file .java
        java_files = list(self.src_dir.glob("*.java"))
        
        for java_file in java_files:
            try:
                with open(java_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # T√¨m public static void main
                    if re.search(r'public\s+static\s+void\s+main\s*\(', content):
                        # L·∫•y t√™n class t·ª´ t√™n file
                        class_name = java_file.stem
                        print(f"‚úì T√¨m th·∫•y main() trong file: {class_name}.java")
                        return class_name
            except:
                continue
        
        # Kh√¥ng t√¨m th·∫•y - b√°o c√°o chi ti·∫øt
        print("\n‚ö†Ô∏è KH√îNG T√åM TH·∫§Y MAIN CLASS!")
        self.report_available_files()
        
        return "main"  # Fallback to default
    
    def report_available_files(self):
        """B√°o c√°o t·∫•t c·∫£ file .java v√† .class c√≥ s·∫µn"""
        print("\n" + "="*60)
        print("üìã DANH S√ÅCH FILE TRONG TH·ª¶ M·ª§C:")
        print("="*60)
        
        # T√¨m t·∫•t c·∫£ file .java
        java_files = list(self.src_dir.rglob("*.java"))
        if java_files:
            print(f"\nüìÑ File .java ({len(java_files)} file):")
            for f in sorted(java_files):
                rel_path = f.relative_to(self.src_dir)
                print(f"   - {rel_path}")
        else:
            print("\nüìÑ File .java: Kh√¥ng t√¨m th·∫•y")
        
        # T√¨m t·∫•t c·∫£ file .class
        class_files = list(self.src_dir.rglob("*.class"))
        if class_files:
            print(f"\nüîπ File .class ({len(class_files)} file):")
            for f in sorted(class_files):
                rel_path = f.relative_to(self.src_dir)
                # L·∫•y t√™n class (kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n v√† extension)
                class_name = str(rel_path).replace('\\', '.').replace('/', '.')[:-6]
                print(f"   - {rel_path} ‚Üí class: {class_name}")
        else:
            print("\nüîπ File .class: Kh√¥ng t√¨m th·∫•y (c·∫ßn bi√™n d·ªãch)")
        
        print("\nüí° G·ª¢I √ù:")
        print("   1. Ki·ªÉm tra xem c√≥ file .class n√†o sau khi compile")
        print("   2. ƒê·∫£m b·∫£o c√≥ file ch·ª©a 'public static void main(String[] args)'")
        print("   3. T√™n class ph·∫£i kh·ªõp v·ªõi t√™n file .java")
        print("="*60 + "\n")
    
    def _try_run_java(self, class_name, input_data):
        """Th·ª≠ ch·∫°y Java v·ªõi t√™n class c·ª• th·ªÉ"""
        try:
            result = subprocess.run(
                ["java", class_name],
                input=input_data,
                capture_output=True,
                text=True,
                cwd=str(self.src_dir),
                timeout=10
            )
            
            # Ch·ªâ l·∫•y ph·∫ßn sau ch·ªØ "OUTPUT:"
            stdout = result.stdout
            if "OUTPUT:" in stdout:
                # L·∫•y ph·∫ßn sau "OUTPUT:" v√† lo·∫°i b·ªè ph·∫ßn BUILD SUCCESSFUL
                output_part = stdout.split("OUTPUT:")[1]
                # Lo·∫°i b·ªè ph·∫ßn BUILD SUCCESSFUL n·∫øu c√≥
                if "BUILD SUCCESSFUL" in output_part:
                    output_part = output_part.split("BUILD SUCCESSFUL")[0]
                stdout = output_part.strip()
            
            return stdout, result.stderr, result.returncode
        except subprocess.TimeoutExpired:
            return "", "TIMEOUT", -1
        except Exception as e:
            return "", str(e), -1
    
    def run_java_with_input(self, input_data):
        """Ch·∫°y main.java v·ªõi input v√† tr·∫£ v·ªÅ output"""
        try:
            # T·ª± ƒë·ªông t√¨m class c√≥ main method
            main_class = self.find_main_class()
            
            # Th·ª≠ ch·∫°y v·ªõi t√™n t√¨m ƒë∆∞·ª£c
            result = self._try_run_java(main_class, input_data)
            if result[2] == 0:  # returncode == 0 nghƒ©a l√† th√†nh c√¥ng
                return result
            
            # N·∫øu fail, th·ª≠ c√°c t√™n ph·ªï bi·∫øn kh√°c
            for fallback_name in ["main", "Main"]:
                if fallback_name != main_class:
                    result = self._try_run_java(fallback_name, input_data)
                    if result[2] == 0:
                        return result
            
            # Tr·∫£ v·ªÅ k·∫øt qu·∫£ cu·ªëi c√πng (c√≥ th·ªÉ l√† l·ªói)
            return result
        except Exception as e:
            return "", str(e), -1
    
    def parse_test_case(self, tc_file):
        """Parse file test case ƒë·ªÉ l·∫•y INPUT, OUTPUT v√† c√°c config"""
        with open(tc_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Parse INPUT
        input_match = re.search(r'INPUT:\s*\n(.*?)\nOUTPUT:', content, re.DOTALL)
        input_data = input_match.group(1).strip() if input_match else ""
        
        # Parse OUTPUT
        output_match = re.search(r'OUTPUT:\s*\n(.*?)\n(?:REMOVE_SPACES|CASE_SENSITIVE|MARK|$)', content, re.DOTALL)
        expected_output = output_match.group(1).strip() if output_match else ""
        
        # Parse configs
        remove_spaces = re.search(r'REMOVE_SPACES:\s*\n(YES|NO)', content)
        remove_spaces = remove_spaces.group(1) == "YES" if remove_spaces else False
        
        case_sensitive = re.search(r'CASE_SENSITIVE:\s*\n(YES|NO)', content)
        case_sensitive = case_sensitive.group(1) == "YES" if case_sensitive else True
        
        mark = re.search(r'MARK:\s*\n([\d.]+)', content)
        mark = float(mark.group(1)) if mark else 0.0
        
        return {
            'input': input_data,
            'expected_output': expected_output,
            'remove_spaces': remove_spaces,
            'case_sensitive': case_sensitive,
            'mark': mark
        }
    
    def normalize_output(self, text, remove_spaces=False, case_sensitive=True):
        """Chu·∫©n h√≥a output theo config"""
        result = text.strip()
        
        if remove_spaces:
            result = re.sub(r'\s+', '', result)
        
        if not case_sensitive:
            result = result.lower()
        
        return result
    
    def compare_outputs(self, actual, expected, remove_spaces=False, case_sensitive=True):
        """So s√°nh output th·ª±c t·∫ø v·ªõi expected"""
        actual_normalized = self.normalize_output(actual, remove_spaces, case_sensitive)
        expected_normalized = self.normalize_output(expected, remove_spaces, case_sensitive)
        
        return actual_normalized == expected_normalized
    
    def run_all_tests(self):
        """Ch·∫°y t·∫•t c·∫£ test cases"""
        # Bi√™n d·ªãch tr∆∞·ªõc
        if not self.compile_java():
            return
        
        print("\n" + "="*60)
        print("B·∫ÆT ƒê·∫¶U CH·∫†Y TEST CASES")
        print("="*60 + "\n")
        
        # L·∫•y t·∫•t c·∫£ test case files
        test_files = sorted(self.test_dir.glob("tc*.txt"))
        
        if not test_files:
            print("Kh√¥ng t√¨m th·∫•y test case n√†o!")
            return
        
        total_mark = 0
        earned_mark = 0
        results = []
        
        for tc_file in test_files:
            tc_name = tc_file.stem
            print(f"--- {tc_name.upper()} ---")
            
            # Parse test case
            tc_data = self.parse_test_case(tc_file)
            
            print(f"Input: {tc_data['input'][:50]}..." if len(tc_data['input']) > 50 else f"Input: {tc_data['input']}")
            print(f"Expected: {tc_data['expected_output'][:50]}..." if len(tc_data['expected_output']) > 50 else f"Expected: {tc_data['expected_output']}")
            
            # Ch·∫°y Java program
            stdout, stderr, returncode = self.run_java_with_input(tc_data['input'])
            
            if returncode != 0:
                print(f"‚úó L·ªñI: {stderr}")
                
                # N·∫øu l·ªói "Could not find or load main class", b√°o c√°o chi ti·∫øt
                if "Could not find or load main class" in stderr:
                    print("\n‚ö†Ô∏è Kh√¥ng th·ªÉ t√¨m th·∫•y ho·∫∑c load main class!")
                    self.report_available_files()
                
                print(f"ƒêi·ªÉm: 0/{tc_data['mark']}\n")
                results.append((tc_name, False, tc_data['mark'], 0))
                total_mark += tc_data['mark']
                continue
            
            print(f"Actual: {stdout[:50]}..." if len(stdout) > 50 else f"Actual: {stdout}")
            
            # So s√°nh k·∫øt qu·∫£
            passed = self.compare_outputs(
                stdout,
                tc_data['expected_output'],
                tc_data['remove_spaces'],
                tc_data['case_sensitive']
            )
            
            if passed:
                print(f"‚úì PASS")
                print(f"ƒêi·ªÉm: {tc_data['mark']}/{tc_data['mark']}\n")
                results.append((tc_name, True, tc_data['mark'], tc_data['mark']))
                earned_mark += tc_data['mark']
            else:
                print(f"‚úó FAIL")
                print(f"ƒêi·ªÉm: 0/{tc_data['mark']}\n")
                results.append((tc_name, False, tc_data['mark'], 0))
            
            total_mark += tc_data['mark']
        
        # T·ªïng k·∫øt
        print("="*60)
        print("T·ªîNG K·∫æT")
        print("="*60)
        for tc_name, passed, max_mark, earned in results:
            status = "‚úì PASS" if passed else "‚úó FAIL"
            print(f"{tc_name}: {status} - {earned}/{max_mark} ƒëi·ªÉm")
        
        print(f"\nT·ªïng ƒëi·ªÉm: {earned_mark}/{total_mark}")
        print(f"T·ª∑ l·ªá: {earned_mark/total_mark*100:.1f}%")
        print("="*60)

def main():
    # C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n
    current_dir = Path.cwd()
    java_dir = current_dir / "given"
    test_dir = current_dir / "TestCases"
    
    # Ki·ªÉm tra th∆∞ m·ª•c t·ªìn t·∫°i
    if not java_dir.exists():
        print(f"Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c: {java_dir}")
        return
    
    if not test_dir.exists():
        print(f"Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c: {test_dir}")
        return
    
    # Ch·∫°y test
    runner = JavaTestRunner(java_dir, test_dir)
    runner.run_all_tests()

if __name__ == "__main__":
    main()